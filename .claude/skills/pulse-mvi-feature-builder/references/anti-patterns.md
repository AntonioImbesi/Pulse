# Pulse MVI Anti-Patterns

Critical mistakes to avoid when building with Pulse MVI.

## Architecture Violations

### ❌ DON'T: Name Intents After UI Events

**Wrong:**
```kotlin
sealed interface LoginIntent {
    data object OnLoginButtonClicked : LoginIntent
    data class OnEmailTextFieldChanged(val email: String) : LoginIntent
    data object OnPasswordVisibilityIconTapped : LoginIntent
}

// In UI:
Button(onClick = { onIntent(LoginIntent.OnLoginButtonClicked) })
```

**Right:**
```kotlin
sealed interface LoginIntent {
    data object Login : LoginIntent // User intent: authenticate
    data class UpdateEmail(val email: String) : LoginIntent // User intent: change email
    data object TogglePasswordVisibility : LoginIntent // User intent: reveal/hide password
}

// In UI:
Button(onClick = { onIntent(LoginIntent.Login) })
```

**Why:** Intent names should describe user goals, not UI interactions. If you change from a button to a swipe gesture, `Login` is still correct, but `OnLoginButtonClicked` becomes meaningless. Intent names should be UI-agnostic and represent domain-level user intentions.

### ❌ DON'T: Use Boolean Flags for Mutually Exclusive States

**Wrong:**
```kotlin
data class SearchState(
    val isLoading: Boolean = false,
    val hasData: Boolean = false,
    val data: List<Item>? = null,
    val error: String? = null
)
// ⚠️ Can have: isLoading=true, hasData=true, data=null, error="Failed"
// What does this state even mean?!
```

**Right:**
```kotlin
data class SearchState(
    val query: String = "",
    val data: DataState = DataState.Idle
) {
    sealed interface DataState {
        data object Idle : DataState
        data object Loading : DataState
        data class Success(val items: List<Item>) : DataState
        data class Error(val message: String) : DataState
    }
}
// ✅ Only valid states are possible!
```

**Why:** Boolean flags allow impossible state combinations. Use sealed interfaces to make impossible states impossible - this is fundamental to robust MVI architecture.

### ❌ DON'T: Implement ProcessorExecutor Manually

**Wrong:**
```kotlin
class MyProcessorExecutor : ProcessorExecutor<FeatureState, FeatureIntent, FeatureSideEffect> {
    override suspend fun execute(
        processorScope: ProcessorScope<FeatureState, FeatureSideEffect>,
        intent: FeatureIntent
    ) {
        when (intent) {
            // Manual routing...
        }
    }
}
```

**Right:**
```kotlin
// Don't implement it! Let KSP generate it.
// Just annotate your processors with @Processor
@Processor
class MyProcessor : IntentProcessor<FeatureState, FeatureIntent.MyIntent, FeatureSideEffect> {
    // Implementation...
}
```

**Why:** The executor is auto-generated by KSP. Manual implementation defeats compile-time safety.

### ❌ DON'T: Forget @Processor Annotation

**Wrong:**
```kotlin
class LoadDataProcessor : IntentProcessor<FeatureState, FeatureIntent.LoadData, FeatureSideEffect> {
    // Missing @Processor annotation!
}
```

**Right:**
```kotlin
@Processor // KSP needs this!
class LoadDataProcessor : IntentProcessor<FeatureState, FeatureIntent.LoadData, FeatureSideEffect> {
    // Implementation...
}
```

**Why:** Without @Processor, KSP won't generate the routing code and your processor won't be called.

### ❌ DON'T: Create Multiple Processors for Same Intent

**Wrong:**
```kotlin
@Processor 
class Processor1 : IntentProcessor<FeatureState, FeatureIntent.Submit, FeatureSideEffect>

@Processor 
class Processor2 : IntentProcessor<FeatureState, FeatureIntent.Submit, FeatureSideEffect>
```

**Why:** Violates 1:1 mapping. Build will fail with ambiguous routing error. Each intent must have exactly one processor.

## State Management Violations

### ❌ DON'T: Use Mutable State

**Wrong:**
```kotlin
data class FeatureState(
    var count: Int, // var!
    val items: MutableList<Item> // MutableList!
)
```

**Right:**
```kotlin
data class FeatureState(
    val count: Int, // val
    val items: List<Item> // Immutable list
)
```

**Why:** Breaks state immutability contract. Use val and immutable collections. Mutable state breaks the MVI pattern and makes state changes unpredictable.

### ❌ DON'T: Directly Assign State

**Wrong:**
```kotlin
override suspend fun ProcessorScope<FeatureState, FeatureSideEffect>.process(
    intent: FeatureIntent
) {
    currentState = currentState.copy(loading = true) // Wrong!
}
```

**Right:**
```kotlin
override suspend fun ProcessorScope<FeatureState, FeatureSideEffect>.process(
    intent: FeatureIntent
) {
    reduce { copy(loading = true) } // Correct!
}
```

**Why:** State must be updated via reduce { } for atomic transitions and observer notifications. Direct assignment bypasses the engine's state management.

### ❌ DON'T: Put Display Data in SideEffects

**Wrong:**
```kotlin
sealed interface FeatureSideEffect {
    data class ShowUserName(val name: String) : FeatureSideEffect // Should be in State!
    data class DisplayProductList(val products: List<Product>) : FeatureSideEffect // Wrong!
}
```

**Right:**
```kotlin
// Put persistent display data in State
data class FeatureState(
    val userName: String = "",
    val products: List<Product> = emptyList()
)

// Side effects are for one-time actions
sealed interface FeatureSideEffect {
    data object NavigateBack : FeatureSideEffect
    data class ShowToast(val message: String) : FeatureSideEffect
}
```

**Why:** Side effects are for one-time actions (navigation, toasts). Persistent display data belongs in State so it survives configuration changes.

### ❌ DON'T: Remove State Fields Without Migration

**Wrong:**
```kotlin
// Version 1
data class FeatureState(val oldField: String, val newField: String)

// Version 2 (breaking change!)
data class FeatureState(val newField: String) // oldField removed without deprecation
```

**Right:**
```kotlin
// Version 1
data class FeatureState(val oldField: String, val newField: String)

// Version 1.1 (deprecation)
data class FeatureState(
    @Deprecated("Use newField") val oldField: String,
    val newField: String
)

// Version 2.0 (safe removal after migration period)
data class FeatureState(val newField: String)
```

**Why:** Breaking changes without migration path cause crashes in production.

## UI Integration Violations

### ❌ DON'T: Use Unsafe Side Effect Collection

**Wrong:**
```kotlin
LaunchedEffect(Unit) {
    viewModel.sideEffect.collect { effect ->
        navController.navigate(...) // Crashes when backgrounded!
    }
}
```

**Right:**
```kotlin
viewModel.collectSideEffect { effect ->
    when (effect) {
        is FeatureSideEffect.Navigate -> navController.navigate(...)
    }
}
```

**Why:** Causes crashes when performing UI operations while app is stopped. collectSideEffect() handles lifecycle automatically.

### ❌ DON'T: Collect State Manually Without Lifecycle

**Wrong:**
```kotlin
LaunchedEffect(Unit) {
    viewModel.state.collect { state ->
        // This runs even when app is backgrounded
    }
}
```

**Right:**
```kotlin
val state by viewModel.collectState() // Lifecycle-aware
```

**Why:** Manual collection without lifecycle awareness wastes resources and can cause issues.

## Error Handling Violations

### ❌ DON'T: Catch and Suppress All Exceptions

**Wrong:**
```kotlin
override suspend fun ProcessorScope<FeatureState, FeatureSideEffect>.process(
    intent: FeatureIntent
) {
    try {
        // logic
    } catch (e: Exception) {
        // Silently ignored - very bad!
    }
}
```

**Right:**
```kotlin
override suspend fun ProcessorScope<FeatureState, FeatureSideEffect>.process(
    intent: FeatureIntent
) {
    try {
        // logic
    } catch (e: NetworkException) {
        // Handle expected errors
        reduce { copy(error = e.message) }
        send(FeatureSideEffect.ShowError(e.message))
    }
    // Let unexpected exceptions propagate
}
```

**Why:** Expected errors should update state, unexpected errors should propagate. Silent failures hide bugs.

### ❌ DON'T: Use Generic Exception Handling

**Wrong:**
```kotlin
try {
    repository.loadData()
} catch (e: Exception) {
    reduce { copy(error = "Something went wrong") }
}
```

**Right:**
```kotlin
try {
    repository.loadData()
} catch (e: NetworkException) {
    reduce { copy(error = "No internet connection") }
    send(FeatureSideEffect.ShowRetry)
} catch (e: AuthException) {
    reduce { copy(error = "Session expired") }
    send(FeatureSideEffect.NavigateToLogin)
}
```

**Why:** Specific error handling provides better user experience and debugging information.

## Dependency Management Violations

### ❌ DON'T: Mix Business Logic in Processors

**Wrong:**
```kotlin
@Processor
class LoginProcessor : IntentProcessor<LoginState, LoginIntent.Login, LoginSideEffect> {
    override suspend fun ProcessorScope<LoginState, LoginSideEffect>.process(
        intent: LoginIntent.Login
    ) {
        reduce { copy(loading = true) }
        
        // Business logic directly in processor - violation of Clean Architecture!
        val hashedPassword = SHA256.hash(intent.password)
        val token = makeHttpRequest("https://api.com/login", intent.email, hashedPassword)
        
        reduce { copy(loading = false, token = token) }
    }
}
```

**Right:**
```kotlin
@Processor
class LoginProcessor(
    private val loginUseCase: LoginUseCase // Delegate to domain layer
) : IntentProcessor<LoginState, LoginIntent.Login, LoginSideEffect> {
    override suspend fun ProcessorScope<LoginState, LoginSideEffect>.process(
        intent: LoginIntent.Login
    ) {
        reduce { copy(loading = true) }
        
        when (val result = loginUseCase(intent.email, intent.password)) {
            is Result.Success -> reduce { copy(loading = false, token = result.token) }
            is Result.Error -> {
                reduce { copy(loading = false, error = result.message) }
                send(LoginSideEffect.ShowError(result.message))
            }
        }
    }
}
```

**Why:** Processors should coordinate, not contain business logic. Follow Clean Architecture: Processor → Use Case → Repository.

### ❌ DON'T: Share State Between Features

**Wrong:**
```kotlin
object GlobalState {
    var loginState: LoginState = LoginState()
    var profileState: ProfileState = ProfileState()
}
```

**Right:**
```kotlin
// Each feature has its own ViewModel with its own State
@HiltViewModel
class LoginViewModel @Inject constructor(...) : MviViewModel<LoginState, LoginIntent, LoginSideEffect>(...)

@HiltViewModel
class ProfileViewModel @Inject constructor(...) : MviViewModel<ProfileState, ProfileIntent, ProfileSideEffect>(...)
```

**Why:** Each feature should have its own State managed by its ViewModel. Violates separation of concerns. Features should communicate via side effects and navigation.

### ❌ DON'T: Dispatch Intents from Processors

**Wrong:**
```kotlin
@Processor
class LoginProcessor(
    private val viewModel: LoginViewModel // Anti-pattern!
) : IntentProcessor<LoginState, LoginIntent.Login, LoginSideEffect> {
    override suspend fun ProcessorScope<LoginState, LoginSideEffect>.process(
        intent: LoginIntent.Login
    ) {
        // ...
        viewModel dispatch LoginIntent.LoadProfile // Wrong!
    }
}
```

**Right:**
```kotlin
@Processor
class LoginProcessor : IntentProcessor<LoginState, LoginIntent.Login, LoginSideEffect> {
    override suspend fun ProcessorScope<LoginState, LoginSideEffect>.process(
        intent: LoginIntent.Login
    ) {
        // ...
        send(LoginSideEffect.TriggerProfileLoad) // Use side effect instead
    }
}

// In UI, handle the side effect
viewModel.collectSideEffect { effect ->
    when (effect) {
        LoginSideEffect.TriggerProfileLoad -> {
            profileViewModel dispatch ProfileIntent.Load
        }
    }
}
```

**Why:** Processors shouldn't have references to ViewModels. Use side effects for cross-feature communication.

## Testing Violations

### ❌ DON'T: Test Implementation Details

**Wrong:**
```kotlin
// Bad: Testing internal state that might change
expectEvents {
    state { it.internalLoadingFlag == true }
    // ...
}
```

**Right:**
```kotlin
// Good: Test observable behavior
expectEvents {
    state { it is LoadingState }
    // ...
}
```

**Why:** Tests should verify behavior, not implementation. Internal details can change without affecting functionality.

### ❌ DON'T: Use Flaky Assertions

**Wrong:**
```kotlin
@Test
fun test() = runTest {
    testProcessor(...) {
        delay(100) // Flaky!
        assertTrue(sideEffects.isNotEmpty())
    }
}
```

**Right:**
```kotlin
@Test
fun test() = runTest {
    testProcessorAsync(...) {
        advanceUntilIdle() // Deterministic
        assertTrue(sideEffects.isNotEmpty())
    }
}
```

**Why:** Delays make tests flaky. Use TestScope's time control for deterministic tests.

## Migration from Boolean Flags to Sealed Interface

When you notice complex conditional logic or impossible states, migrate to sealed interfaces:

**Before (Boolean Flags - Problematic):**
```kotlin
data class ProfileState(
    val isLoading: Boolean = false,
    val isRefreshing: Boolean = false,
    val hasData: Boolean = false,
    val profile: Profile? = null,
    val error: String? = null
)

// UI - Complex and error-prone
@Composable
fun ProfileScreen(state: ProfileState) {
    when {
        state.isLoading && !state.hasData -> FullScreenLoading()
        state.isRefreshing && state.hasData -> {
            ProfileContent(state.profile!!)
            PullToRefreshIndicator()
        }
        state.error != null && !state.hasData -> ErrorScreen(state.error)
        state.hasData -> ProfileContent(state.profile!!)
        else -> EmptyScreen() // What even triggers this?
    }
}
```

**After (Sealed Interface - Type-Safe):**
```kotlin
data class ProfileState(
    val profile: ProfileData = ProfileData.Loading
) {
    sealed interface ProfileData {
        data object Loading : ProfileData
        data class Loaded(
            val profile: Profile,
            val isRefreshing: Boolean = false
        ) : ProfileData
        data class Error(val message: String) : ProfileData
    }
}

// UI - Type-safe and exhaustive
@Composable
fun ProfileScreen(state: ProfileState) {
    when (val profile = state.profile) {
        is ProfileState.ProfileData.Loading -> FullScreenLoading()
        is ProfileState.ProfileData.Loaded -> {
            ProfileContent(profile.profile)
            if (profile.isRefreshing) {
                PullToRefreshIndicator()
            }
        }
        is ProfileState.ProfileData.Error -> ErrorScreen(profile.message)
    }
}
```

**Migration Steps:**
1. Create sealed interface for the mutually exclusive states
2. Update State to use sealed interface
3. Update all processors to set sealed interface states
4. Update UI to use `when` expression with sealed interface
5. Remove old boolean flags and nullable fields
6. Rebuild and test

**Benefits of migration:**
- Compiler enforces handling all states
- Impossible to create invalid state combinations
- UI code is clearer and safer
- Easier to add new states (e.g., "Refreshing with stale data")

## Summary

The common theme across all anti-patterns:

1. **Respect the MVI contract**: State is immutable, Intents represent user goals, SideEffects are one-time events
2. **Let the framework do its job**: Don't bypass reduce { }, don't implement ProcessorExecutor manually
3. **Use type safety**: Sealed interfaces over boolean flags, exhaustive when expressions
4. **Separate concerns**: Business logic in domain layer, coordination in processors
5. **Lifecycle awareness**: Always use the provided helpers (collectState, collectSideEffect)

When in doubt, ask: "Am I fighting the framework or working with it?" If you're fighting, you're probably doing an anti-pattern.