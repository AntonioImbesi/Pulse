package io.github.antonioimbesi.pulse.compiler

import com.google.devtools.ksp.processing.Resolver
import io.github.antonioimbesi.pulse.core.processor.InitProcessor
import io.github.antonioimbesi.pulse.core.processor.IntentProcessor
import io.github.antonioimbesi.pulse.core.processor.ProcessorScope
import io.github.antonioimbesi.pulse.core.processor.ProcessorExecutor

/**
 * Template-based code generator for [ProcessorExecutor][io.github.antonioimbesi.pulse.core.processor.ProcessorExecutor] implementations.
 *
 * Assembles Kotlin source code by combining:
 * - Import statements for all referenced types
 * - Constructor parameters for each processor dependency
 * - A `when` expression routing each intent to its processor
 * - Optional `getInitProcessor()` method if an init processor exists
 *
 * The generated executor is placed in a `.generated` subpackage and optionally
 * annotated with `@Inject` when `javax.inject` is on the classpath.
 *
 * @see ProcessorExecutorGenerator The symbol processor that invokes this factory
 */
internal object ProcessorExecutorFactory {

    // Intentionally deviates from Kotlin's UPPER_SNAKE_CASE convention for const vals.
    // Using camelCase for a private compile-time constant to align with local
    // configuration-style identifiers.
    @Suppress("ConstPropertyName")
    private const val javaInjectName = "javax.inject.Inject"

    /**
     * Generates the complete Kotlin source for a ProcessorExecutor implementation.
     *
     * @param packageName The target package for the generated class (typically `.generated`).
     * @param executorClassName The simple name for the generated executor class.
     * @param processors The list of processors to route intents to.
     * @param resolver KSP resolver for checking classpath dependencies (e.g., javax.inject).
     * @return The complete Kotlin source file content as a string.
     */
    internal fun generate(
        packageName: String,
        executorClassName: String,
        processors: List<ProcessorInfo>,
        resolver: Resolver
    ): String {
        val mviContractInfo = MviContractInfo.from(processors)

        val imports = buildImports(
            processors = processors,
            mviContractInfo = mviContractInfo,
            resolver = resolver,
        )
        val constructorParams = buildConstructorParameters(processors)
        val whenCases = buildWhenCases(processors)
        val getInitProcessor = buildGetInitProcessor(processors, mviContractInfo)
        val injectAnnotation = if (isJavaInjectAvailable(resolver)) "@$javaInjectName " else ""

        val stateSimpleName = mviContractInfo.stateType.declaration.simpleName.asString()
        val baseIntentSimpleName = mviContractInfo.baseIntentType?.declaration?.simpleName?.asString()
            ?: "Nothing" // If only init processor exists
        val sideEffectSimpleName = mviContractInfo.sideEffectType.declaration.simpleName.asString()
        val processorExecutorSimpleName = ProcessorExecutor::class.simpleName

        return """
        |// Generated by KSP, do not edit
        |package $packageName
        |
        |$imports
        |
        |internal class $executorClassName ${injectAnnotation}constructor(
        |    $constructorParams
        |): $processorExecutorSimpleName<$stateSimpleName, $baseIntentSimpleName, $sideEffectSimpleName> {
        |    override suspend fun execute(
        |        processorScope: ProcessorScope<$stateSimpleName, $sideEffectSimpleName>,
        |        intent: $baseIntentSimpleName
        |    ) {
        |        when (intent) {
        |$whenCases
        |        }
        |    }
        |$getInitProcessor
        |}
        """.trimMargin()
    }

    /**
     * Builds the sorted import block for the generated file.
     *
     * Includes core Pulse types, all processor classes, their handled intents,
     * and optionally `javax.inject.Inject` when available.
     */
    private fun buildImports(
        processors: List<ProcessorInfo>,
        mviContractInfo: MviContractInfo,
        resolver: Resolver
    ): String {
        val imports = mutableSetOf(
            IntentProcessor::class.qualifiedName!!,
            ProcessorScope::class.qualifiedName!!,
            ProcessorExecutor::class.qualifiedName!!,
            mviContractInfo.stateType.declaration.qualifiedName!!.asString(),
            mviContractInfo.sideEffectType.declaration.qualifiedName!!.asString(),
        )

        // Add base intent type if it exists (not null for features with intent processors)
        mviContractInfo.baseIntentType?.let {
            imports.add(it.declaration.qualifiedName!!.asString())
        }

        if (isJavaInjectAvailable(resolver)) {
            imports.add(javaInjectName)
        }

        // Add init processor interface if needed
        if (processors.any { it.processorKind == ProcessorInfo.ProcessorKind.INIT }) {
            imports.add(InitProcessor::class.qualifiedName!!)
        }

        processors.forEach { info ->
            imports.add(info.parameterType.declaration.qualifiedName!!.asString())
            // Only add intent type for intent processors
            if (info.processorKind == ProcessorInfo.ProcessorKind.INTENT) {
                imports.add(info.handledIntentType!!.declaration.qualifiedName!!.asString())
            }
        }

        return imports.sorted().joinToString("\n") { "import $it" }
    }

    /**
     * Generates constructor parameter declarations for processor injection.
     *
     * Each processor becomes a `private val` constructor parameter, enabling
     * dependency injection frameworks to provide the instances.
     */
    private fun buildConstructorParameters(processors: List<ProcessorInfo>): String {
        return processors.joinToString(separator = ",\n    ") {
            "private val ${it.parameterName}: ${it.parameterType.declaration.simpleName.asString()}"
        }
    }

    /**
     * Generates the `when` expression branches for intent routing.
     *
     * Each branch matches a specific intent subtype and delegates to the
     * corresponding processor using Kotlin's `with` scope function.
     *
     * Only generates branches for intent processors (not init processors).
     */
    private fun buildWhenCases(processors: List<ProcessorInfo>): String {
        val intentProcessors = processors.filter { it.processorKind == ProcessorInfo.ProcessorKind.INTENT }

        if (intentProcessors.isEmpty()) {
            return "            // No intent processors defined"
        }

        return intentProcessors.joinToString(separator = "\n") {
            """
            |            is ${it.handledIntentType!!.declaration.qualifiedName!!.asString()} ->
            |                with(${it.parameterName}) { processorScope.process(intent) }
            """.trimMargin()
        }
    }

    /**
     * Generates the `getInitProcessor()` method override if an init processor exists.
     *
     * At most one init processor is allowed per feature. The KSP processor validates
     * this constraint during symbol processing.
     */
    private fun buildGetInitProcessor(
        processors: List<ProcessorInfo>,
        mviContractInfo: MviContractInfo
    ): String {
        val initProcessor = processors.firstOrNull { it.processorKind == ProcessorInfo.ProcessorKind.INIT }
            ?: return ""

        val stateSimpleName = mviContractInfo.stateType.declaration.simpleName.asString()
        val sideEffectSimpleName = mviContractInfo.sideEffectType.declaration.simpleName.asString()

        return """
        |
        |    override fun getInitProcessor(): InitProcessor<$stateSimpleName, $sideEffectSimpleName>? {
        |        return ${initProcessor.parameterName}
        |    }
        """.trimMargin()
    }

    /**
     * Checks if `javax.inject.Inject` is on the classpath.
     *
     * When available, the generated executor is annotated with `@Inject` to enable
     * automatic dependency injection without manual Hilt/Dagger module bindings.
     */
    private fun isJavaInjectAvailable(resolver: Resolver): Boolean {
        return resolver.getClassDeclarationByName(
            name = resolver.getKSNameFromString(javaInjectName)
        ) != null
    }
}