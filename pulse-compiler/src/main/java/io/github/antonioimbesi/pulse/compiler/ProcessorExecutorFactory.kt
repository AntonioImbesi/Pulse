package io.github.antonioimbesi.pulse.compiler

import com.google.devtools.ksp.processing.Resolver
import io.github.antonioimbesi.pulse.core.processor.IntentProcessor
import io.github.antonioimbesi.pulse.core.processor.ProcessorScope
import io.github.antonioimbesi.pulse.core.processor.ProcessorExecutor

internal object ProcessorExecutorFactory {

    // The usage of UPPER_SNAKE_CASE is a convention coming from Java. In Kotlin,
    // the misuse of these variables won't lead to the same mistakes.
    // I'm not against the usage of UPPER_SNAKE_CASE, it's more of a personal choice.
    @Suppress("ConstPropertyName")
    private const val javaInjectName = "javax.inject.Inject"

    internal fun generate(
        packageName: String,
        executorClassName: String,
        processors: List<ProcessorInfo>,
        resolver: Resolver
    ): String {
        val mviContractInfo = MviContractInfo.Companion.from(processors)

        val imports = buildImports(
            processors = processors,
            mviContractInfo = mviContractInfo,
            resolver = resolver,
        )
        val constructorParams = buildConstructorParameters(processors)
        val whenCases = buildWhenCases(processors)
        val injectAnnotation = if (isJavaInjectAvailable(resolver)) "@$javaInjectName " else ""

        val stateSimpleName = mviContractInfo.stateType.declaration.simpleName.asString()
        val baseIntentSimpleName =
            mviContractInfo.baseIntentType.declaration.simpleName.asString()
        val sideEffectSimpleName = mviContractInfo.sideEffectType.declaration.simpleName.asString()
        val processorExecutorSimpleName = ProcessorExecutor::class.simpleName

        return """
        |// Generated by KSP, do not edit
        |package $packageName
        |
        |$imports
        |
        |internal class $executorClassName ${injectAnnotation}constructor(
        |    $constructorParams
        |): $processorExecutorSimpleName<$stateSimpleName, $baseIntentSimpleName, $sideEffectSimpleName> {
        |    override suspend fun execute(
        |        context: ProcessorScope<$stateSimpleName, $sideEffectSimpleName>,
        |        intent: $baseIntentSimpleName
        |    ) {
        |        when (intent) {
        |$whenCases
        |        }
        |    }
        |}
        """.trimMargin()
    }

    private fun buildImports(
        processors: List<ProcessorInfo>,
        mviContractInfo: MviContractInfo,
        resolver: Resolver
    ): String {
        val imports = mutableSetOf(
            IntentProcessor::class.qualifiedName!!,
            ProcessorScope::class.qualifiedName!!,
            ProcessorExecutor::class.qualifiedName!!,
            mviContractInfo.stateType.declaration.qualifiedName!!.asString(),
            mviContractInfo.sideEffectType.declaration.qualifiedName!!.asString(),
            mviContractInfo.baseIntentType.declaration.qualifiedName!!.asString()
        )

        if (isJavaInjectAvailable(resolver)) {
            imports.add(javaInjectName)
        }

        processors.forEach { info ->
            imports.add(info.parameterType.declaration.qualifiedName!!.asString())
            imports.add(info.handledIntentType.declaration.qualifiedName!!.asString())
        }

        return imports.sorted().joinToString("\n") { "import $it" }
    }

    private fun buildConstructorParameters(processors: List<ProcessorInfo>): String {
        return processors.joinToString(separator = ",\n    ") {
            "private val ${it.parameterName}: ${it.parameterType.declaration.simpleName.asString()}"
        }
    }

    private fun buildWhenCases(processors: List<ProcessorInfo>): String {
        return processors.joinToString(separator = "\n") {
            """
            |            is ${it.handledIntentType.declaration.qualifiedName!!.asString()} ->
            |                with(${it.parameterName}) { context.process(intent) }
            """.trimMargin()
        }
    }

    private fun isJavaInjectAvailable(resolver: Resolver): Boolean {
        return resolver.getClassDeclarationByName(
            name = resolver.getKSNameFromString(javaInjectName)
        ) != null
    }
}
